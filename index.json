[{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -\u0026gt; N is number of nodes 2^k\u0026lt;=N So k\u0026lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -\u0026gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table. During LCA jump just close to LCA. Check if jumping makes them equal if not then make the jump. Do this until ur able to make a jump. Finally the answer would be an immediate parent of a node. Preprocessing is O(NlogN) and per query its O(logN) Space is O(NlogN)      Do Bfs for depth wrt to any root node void bfs(vector\u0026amp; adj,vector\u0026amp; par,VII\u0026amp; depth,int\u0026amp; n) { //arbitrarily root the tree  VII vis(n,false); depth[0]=0; vis[0]=true; queue q; q.push(0); while(!q.empty()) { int u=q.front(); q.pop(); for(auto it:adj[u]) if(!vis[it]) { vis[it]=true; depth[it]=depth[u]+1; par[0][it]=u; q.push(it); } } } Preprocess void preprocess(vector\u0026lt;VII\u0026gt;\u0026amp; par,int\u0026amp; n,int\u0026amp; D) { for(int d=0;d\u0026lt;=D;++d) { for(int i=0;i\u0026lt;n;++i) { int mid=par[d-1][i]; if(mid!=-1) par[d][i]=par[d-1][mid]; } } } Walk and LCA int walk(int i,int k,int\u0026amp; D,vector\u0026lt;VII\u0026gt;\u0026amp; par) { //To make a node i at depth d  for(int d=0;d\u0026lt;=D \u0026amp;\u0026amp; i!=-1;++d) if((1\u0026lt;\u0026lt;d)\u0026amp;k)i=par[d][i]; return i; } int LCA(int a,int b,vector\u0026lt;VII\u0026gt;\u0026amp; par,VII\u0026amp; depth,int \u0026amp;D) { if(depth[a]\u0026gt;depth[b]) a=walk(a,depth[a]-depth[b],D,par); else if(depth[b]\u0026gt;depth[a]) b=walk(b,depth[b]-depth[a],D,par); if(a==b) return a; for(int d=D;d\u0026gt;=0;--d) { //to go close faster make big jumps  if(par[d][a]!=par[d][b]) { a=par[d][a]; b=par[d][b]; } } return par[0][a]; } int D=log2(n); ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/","summary":"LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -\u0026gt; N is number of nodes 2^k\u0026lt;=N So k\u0026lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -\u0026gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table.","tags":null,"title":"LCA"},{"categories":null,"contents":"Fenwick Tree #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; class FenwickTree { vector\u0026lt;T\u0026gt; BIT; int n; public: FenwickTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr,T def) { BIT.assign(n + 1, def); this-\u0026gt;n = n; } void update(int i,T v) { while (i \u0026lt;= n) BIT[i] += v, i += i \u0026amp; -i; } T query(int i,T def) { //get from 0 to i  T sum = def; while(i\u0026gt;0) sum += BIT[i], i -= i \u0026amp; -i; return sum; } }; class RangeFenwickTree { int n; vector\u0026lt;int\u0026gt; BIT1; vector\u0026lt;int\u0026gt; BIT2; public: RangeFenwickTree(int n,vector\u0026lt;int\u0026gt;\u0026amp; arr) { this-\u0026gt;n = n; BIT1.assign(n + 1, 0); BIT2.assign(n + 1, 0); for (int i = 1; i \u0026lt;= n;++i) update_range(i, i, arr[i]); } static void update(vector\u0026lt;int\u0026gt;\u0026amp; BIT,int i,int v,int n) { while(i\u0026lt;=n) BIT[i] += v, i += i \u0026amp; -i; } void update_range(int l,int r,int v) { update(BIT1, l, v, n); update(BIT1, r + 1, -v, n); update(BIT2, l, v * (l - 1), n); update(BIT2, r+1, -v * r, n); } static int sum(int r,vector\u0026lt;int\u0026gt;\u0026amp; BIT) { int sum = 0; while(r\u0026gt;0) sum += BIT[r], r -= r \u0026amp; -r; return sum; } int prefix_sum(int r) { return sum(r, BIT1) * r - sum(r, BIT2); } int range_sum(int l,int r) { return prefix_sum(r) - prefix_sum(l - 1); } }; int main() { //Test program  int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; arr(n + 1); for (int i = 1; i \u0026lt;= n;++i) cin \u0026gt;\u0026gt; arr[i]; RangeFenwickTree tree(n,arr); int q; cin \u0026gt;\u0026gt; q; while(q--) { int type; cin \u0026gt;\u0026gt; type; if(type==1) { //range sum  int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; \u0026#34;Ans:\u0026#34; \u0026lt;\u0026lt; tree.range_sum(l, r) \u0026lt;\u0026lt; endl; } else{ //add to all elements  int l, r, v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; tree.update_range(l, r, v); } } return 0; } Segment Trees template\u0026lt;typename T\u0026gt; class SegmentTree { int n; vector\u0026lt;T\u0026gt; seg; public: SegmentTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr):seg(2*n+1,0) { this-\u0026gt;n=n; for(int i=0;i\u0026lt;n;++i) seg[i+n]=arr[i]; for(int i=n-1;i\u0026gt;0;--i) seg[i]=seg[2*i]+seg[2*i+1]; } void update(int i,T v) { i+=n; seg[i]+=v; while(i\u0026gt;1) { i/=2; seg[i]=seg[2*i]+seg[2*i+1]; } } T query(int l,int r) { //l inclusive r excluded  l+=n; r+=n; T sum=0; while(l\u0026lt;r) { if(l\u0026amp;1) sum+=seg[l],l++; if(r\u0026amp;1) r--,sum+=seg[r]; l/=2; r/=2; } return sum; } }; LCA class LCA { int n, q, D; vector\u0026lt;int\u0026gt; lev; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; public: LCA(int n,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; adj) { this-\u0026gt;n = n; this-\u0026gt;adj = adj; lev.assign(n + 1, 0); D = 31; dp.assign(n + 1, vector\u0026lt;int\u0026gt;(D + 1, 0)); } int walk(int i, int k) { for (int d = 0; d \u0026lt;= D; ++d) if (k \u0026amp; (1 \u0026lt;\u0026lt; d)) i = dp[i][d]; return i; } void dfs(int i, int l, int p) { if (p != -1) dp[i][0] = p; lev[i] = l; for (auto it : adj[i]) if (it != p) dfs(it, l + 1, i); } void preprocess() { for (int d = 1; d \u0026lt;= D; ++d) { for (int i = 1; i \u0026lt;= n; ++i) { int mid = dp[i][d - 1]; if (mid != 0) { dp[i][d] = dp[mid][d - 1]; } } } } int lca(int x, int y) { if (lev[x] \u0026gt; lev[y]) x = walk(x, lev[x] - lev[y]); else if (lev[x] \u0026lt; lev[y]) y = walk(y, lev[y] - lev[x]); if (x == y) return x; for (int d = D; d \u0026gt;= 0; --d) { if (dp[x][d] != dp[y][d]) { x = dp[x][d]; y = dp[y][d]; } } return dp[x][0]; } int dist(int x,int y) { //handle root cases differently  return lev[x] + lev[y] - 2 * lev[lca(x, y)]; } }; ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/template-library/","summary":"Fenwick Tree #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; class FenwickTree { vector\u0026lt;T\u0026gt; BIT; int n; public: FenwickTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr,T def) { BIT.assign(n + 1, def); this-\u0026gt;n = n; } void update(int i,T v) { while (i \u0026lt;= n) BIT[i] += v, i += i \u0026amp; -i; } T query(int i,T def) { //get from 0 to i  T sum = def; while(i\u0026gt;0) sum += BIT[i], i -= i \u0026amp; -i; return sum; } }; class RangeFenwickTree { int n; vector\u0026lt;int\u0026gt; BIT1; vector\u0026lt;int\u0026gt; BIT2; public: RangeFenwickTree(int n,vector\u0026lt;int\u0026gt;\u0026amp; arr) { this-\u0026gt;n = n; BIT1.","tags":null,"title":"Template Library"},{"categories":null,"contents":"Some Facts about trees  Simple path is a path that doesn\u0026rsquo;t contain any node twice. A tree has n-1 edges!  Segment Trees Use segment trees for questions on updating values and querying. Can be used with complex operations like pairs,sets etc. Find very effecient and faster updating (used to insert too), by Finding path to root from one node.\nvoid update(int pos,int val){ pos += k; tree[pos] = val; int odd = 1; //this switches between alternate levels of the segment tree goes upwards  while(pos\u0026gt;\u0026gt;=1 \u0026gt;0){ /* use this in case for level switching if(odd) tree[pos] = tree[2*pos] | tree[2*pos+1]; else tree[pos] = tree[2*pos] ^ tree[2*pos+1]; odd = 1-odd; */ tree[pos]=tree[2*pos]+tree[2*pos+1]; } } for(int i=0;i\u0026lt;n;i++){ int val; cin\u0026gt;\u0026gt;val; update(i,val); } ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/trees/","summary":"Some Facts about trees  Simple path is a path that doesn\u0026rsquo;t contain any node twice. A tree has n-1 edges!  Segment Trees Use segment trees for questions on updating values and querying. Can be used with complex operations like pairs,sets etc. Find very effecient and faster updating (used to insert too), by Finding path to root from one node.\nvoid update(int pos,int val){ pos += k; tree[pos] = val; int odd = 1; //this switches between alternate levels of the segment tree goes upwards  while(pos\u0026gt;\u0026gt;=1 \u0026gt;0){ /* use this in case for level switching if(odd) tree[pos] = tree[2*pos] | tree[2*pos+1]; else tree[pos] = tree[2*pos] ^ tree[2*pos+1]; odd = 1-odd; */ tree[pos]=tree[2*pos]+tree[2*pos+1]; } } for(int i=0;i\u0026lt;n;i++){ int val; cin\u0026gt;\u0026gt;val; update(i,val); } ","tags":null,"title":"Trees"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]