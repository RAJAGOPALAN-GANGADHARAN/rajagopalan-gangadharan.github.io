[{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/bellman-ford/","summary":"","tags":null,"title":"Bellman Ford"},{"categories":null,"contents":"Increasing Array lower_bound() returns value that is greater than or equal to x;\nupper_bound() returns value strictly greater than x;\nDecreasing array: lower_bound() returns value that is less than or equal to x;\nupper_bound() retruns value that is strictly less than x;\n","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/binary-search/","summary":"Increasing Array lower_bound() returns value that is greater than or equal to x;\nupper_bound() returns value strictly greater than x;\nDecreasing array: lower_bound() returns value that is less than or equal to x;\nupper_bound() retruns value that is strictly less than x;","tags":null,"title":"Binary Search"},{"categories":null,"contents":"A very useful technique.It basically has 2 arrays one is Intime and the other is outTime. inTime says when it enters a recursion stack and outTime says when it exits the recursion stack. It is useful to check if a node v is present in the subtree of node u. If inTime[u]\u0026lt;inTime[v] and outTime[u]\u0026gt; outTime[v].\nIt can also be useful in counting number of nodes that belong to a particular tree at a particular height.\nvoid dfs(int u,int par,int level){ startTime[u]=++tim; for(int v: g[u]){ if(v!=par){ dfs(v,u,level+1); } } endTime[u]=tim; } int count() { //number of nodes at cur level that is descendent of pth par is counted.  int ans=(upper_bound(all(lvl[cur]),endTime[pthpar])-lower_bound(all(lvl[cur]),startTime[pthpar])); } ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/dfs-order/","summary":"A very useful technique.It basically has 2 arrays one is Intime and the other is outTime. inTime says when it enters a recursion stack and outTime says when it exits the recursion stack. It is useful to check if a node v is present in the subtree of node u. If inTime[u]\u0026lt;inTime[v] and outTime[u]\u0026gt; outTime[v].\nIt can also be useful in counting number of nodes that belong to a particular tree at a particular height.","tags":null,"title":"DFS Order"},{"categories":null,"contents":"Online vs Offline Online algorithm means getting output after processing at ith element for eg: median of a stream of elements, Whereas in case of online means using all n elements to arrive at an output.\n","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/general/","summary":"Online vs Offline Online algorithm means getting output after processing at ith element for eg: median of a stream of elements, Whereas in case of online means using all n elements to arrive at an output.","tags":null,"title":"General facts"},{"categories":null,"contents":"LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -\u0026gt; N is number of nodes 2^k\u0026lt;=N So k\u0026lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -\u0026gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table. During LCA jump just close to LCA. Check if jumping makes them equal if not then make the jump. Do this until ur able to make a jump. Finally the answer would be an immediate parent of a node. Preprocessing is O(NlogN) and per query its O(logN) Space is O(NlogN)      Do Bfs for depth wrt to any root node void bfs(vector\u0026amp; adj,vector\u0026amp; par,VII\u0026amp; depth,int\u0026amp; n) { //arbitrarily root the tree  VII vis(n,false); depth[0]=0; vis[0]=true; queue q; q.push(0); while(!q.empty()) { int u=q.front(); q.pop(); for(auto it:adj[u]) if(!vis[it]) { vis[it]=true; depth[it]=depth[u]+1; par[0][it]=u; q.push(it); } } } Preprocess void preprocess(vector\u0026lt;VII\u0026gt;\u0026amp; par,int\u0026amp; n,int\u0026amp; D) { for(int d=0;d\u0026lt;=D;++d) { for(int i=0;i\u0026lt;n;++i) { int mid=par[d-1][i]; if(mid!=-1) par[d][i]=par[d-1][mid]; } } } Walk and LCA int walk(int i,int k,int\u0026amp; D,vector\u0026lt;VII\u0026gt;\u0026amp; par) { //To make a node i at depth d  for(int d=0;d\u0026lt;=D \u0026amp;\u0026amp; i!=-1;++d) if((1\u0026lt;\u0026lt;d)\u0026amp;k)i=par[d][i]; return i; } int LCA(int a,int b,vector\u0026lt;VII\u0026gt;\u0026amp; par,VII\u0026amp; depth,int \u0026amp;D) { if(depth[a]\u0026gt;depth[b]) a=walk(a,depth[a]-depth[b],D,par); else if(depth[b]\u0026gt;depth[a]) b=walk(b,depth[b]-depth[a],D,par); if(a==b) return a; for(int d=D;d\u0026gt;=0;--d) { //to go close faster make big jumps  if(par[d][a]!=par[d][b]) { a=par[d][a]; b=par[d][b]; } } return par[0][a]; } int D=log2(n); ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/","summary":"LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -\u0026gt; N is number of nodes 2^k\u0026lt;=N So k\u0026lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -\u0026gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table.","tags":null,"title":"LCA"},{"categories":null,"contents":"Segmented Sieve Use When we have to generate large number of prime Numbers Click Here\n BitHacks Number of bits required to represent a number: \nFor More Bit Tricks:Click Here  Useful nCr Technique Divide by their GCD\u0026rsquo;s to prevent overflow\nFor fast Calculation:\nll NcR(ll n, ll r) { ll p = 1, k = 1; if (n - r \u0026lt; r) r = n - r; if (r != 0) { while (r) { p *= n; k *= r; ll m = __gcd(p, k); p /= m; k /= m; n--; r--; } } else p = 1; return p; }  Cool Geometry Properties  Find Area of triangle using Side length Heron\u0026rsquo;s Formula.  \n Cool Mod properties (a+b) % m = (a % m+b % m) % m (a-b) % m = (a % mâˆ’b % m) % m (a*b) % m = (a % m*b % m) % m  Comparing Double values if(abs(a-b)\u0026lt;1e-9) { cout\u0026lt;\u0026lt;\u0026#34;a and b are equal\u0026#34;; }  GCD Properties  gcd(a,b)=gcd(a,b%a) Let X=gcd(a,b) then gcd(X/a,X/b)=1   Find divisors of a number for (int i = 2; i * 1ll * i \u0026lt;= x; ++i) { if (x % i == 0) { dd.push_back(i); if (i != x / i) { dd.push_back(x / i); } } }  Goldbachs Conjecture  It says any number can be expressed as a sum of 2 prime numbers.   Cool Problems    When asked how to make two numbers equal by series of divisions Represent those numbers in terms of powers of those numbers.  for eg allowed operations are /2,/3,/5 then A=x*2^a * 3^b * 5^c B=y*2^a2 * 3^b2 * 5^c2 if x is same as y it can be made equal\u0026lt;/p\u0026gt;    ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/maths/","summary":"Segmented Sieve Use When we have to generate large number of prime Numbers Click Here\n BitHacks Number of bits required to represent a number: \nFor More Bit Tricks:Click Here  Useful nCr Technique Divide by their GCD\u0026rsquo;s to prevent overflow\nFor fast Calculation:\nll NcR(ll n, ll r) { ll p = 1, k = 1; if (n - r \u0026lt; r) r = n - r; if (r !","tags":null,"title":"Math facts"},{"categories":null,"contents":"It is an online sorting algorithm aimed to create piles of cards in such a way that piles are in increasing order down wards.\nIt can be used to find LIS in O(NlogN) time. Can also be used to find (minimum)number of distinct LIS.\nVII dp; for(int i=arr.size()-1;i\u0026gt;=0;--i) { int x=arr[i]; auto it=upper_bound(all(dp),x); if(it==dp.end()) dp.pb(x); else *it=x; } cout\u0026lt;\u0026lt;dp.size(); ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/patience-sort/","summary":"It is an online sorting algorithm aimed to create piles of cards in such a way that piles are in increasing order down wards.\nIt can be used to find LIS in O(NlogN) time. Can also be used to find (minimum)number of distinct LIS.\nVII dp; for(int i=arr.size()-1;i\u0026gt;=0;--i) { int x=arr[i]; auto it=upper_bound(all(dp),x); if(it==dp.end()) dp.pb(x); else *it=x; } cout\u0026lt;\u0026lt;dp.size(); ","tags":null,"title":"Patience Sort"},{"categories":null,"contents":"Kosaraju\u0026rsquo;s SCC A strongly Connected Component is for a directed graph. For an undirected graph we say it is a connected Component if we can reach a vertex from any vertex of a connected component. In case of SCC its same but called differently.\nSteps  Perform DFS in forward graph and make a note of nodes in decreasing order of outtime. Perform DFS in reverse graph(instead of for loop use the decreasing order u found). Everything reachable in a component (during second DFS) falls inside an SCC. Time Complexity is O(V+E)  int sz = 200005; vector\u0026lt;VII\u0026gt; adj(sz),rev(sz); vector\u0026lt;bool\u0026gt; vis(sz,false); vector\u0026lt;VII\u0026gt; SCC(sz); int comp = 0; VII topo; void dfs_forward(int u) { for(auto it:adj[u]) { if(!vis[it]) { vis[it] = true; dfs_forward(it); } } topo.pb(u); } void dfs_backward(int u) { SCC[comp].pb(u); for(auto it:rev[u]) { if(!vis[it]) { vis[it] = true; dfs_backward(it); } } } main() { int n,m; cin \u0026gt;\u0026gt; n\u0026gt;\u0026gt;m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; adj[x].pb(y); rev[y].pb(x); } for (int i = 1; i \u0026lt;= n;++i) { if(!vis[i]) { vis[i] = 1; dfs_forward(i); } } reverse(all(topo)); vis.assign(sz, false); for(auto x:topo) { if(!vis[x]) { vis[x] = true; comp++; dfs_backward(x); } } for (int i = 1; i \u0026lt;= comp;++i) { for(auto sc:SCC[i]) cout \u0026lt;\u0026lt; sc \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-tech/scc/","summary":"Kosaraju\u0026rsquo;s SCC A strongly Connected Component is for a directed graph. For an undirected graph we say it is a connected Component if we can reach a vertex from any vertex of a connected component. In case of SCC its same but called differently.\nSteps  Perform DFS in forward graph and make a note of nodes in decreasing order of outtime. Perform DFS in reverse graph(instead of for loop use the decreasing order u found).","tags":null,"title":"SCC"},{"categories":null,"contents":"Fenwick Tree #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; class FenwickTree { vector\u0026lt;T\u0026gt; BIT; int n; public: FenwickTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr,T def) { BIT.assign(n + 1, def); this-\u0026gt;n = n; } void update(int i,T v) { while (i \u0026lt;= n) BIT[i] += v, i += i \u0026amp; -i; } T query(int i,T def) { //get from 0 to i  T sum = def; while(i\u0026gt;0) sum += BIT[i], i -= i \u0026amp; -i; return sum; } }; class RangeFenwickTree { int n; vector\u0026lt;int\u0026gt; BIT1; vector\u0026lt;int\u0026gt; BIT2; public: RangeFenwickTree(int n,vector\u0026lt;int\u0026gt;\u0026amp; arr) { this-\u0026gt;n = n; BIT1.assign(n + 1, 0); BIT2.assign(n + 1, 0); for (int i = 1; i \u0026lt;= n;++i) update_range(i, i, arr[i]); } static void update(vector\u0026lt;int\u0026gt;\u0026amp; BIT,int i,int v,int n) { while(i\u0026lt;=n) BIT[i] += v, i += i \u0026amp; -i; } void update_range(int l,int r,int v) { update(BIT1, l, v, n); update(BIT1, r + 1, -v, n); update(BIT2, l, v * (l - 1), n); update(BIT2, r+1, -v * r, n); } static int sum(int r,vector\u0026lt;int\u0026gt;\u0026amp; BIT) { int sum = 0; while(r\u0026gt;0) sum += BIT[r], r -= r \u0026amp; -r; return sum; } int prefix_sum(int r) { return sum(r, BIT1) * r - sum(r, BIT2); } int range_sum(int l,int r) { return prefix_sum(r) - prefix_sum(l - 1); } }; int main() { //Test program  int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; arr(n + 1); for (int i = 1; i \u0026lt;= n;++i) cin \u0026gt;\u0026gt; arr[i]; RangeFenwickTree tree(n,arr); int q; cin \u0026gt;\u0026gt; q; while(q--) { int type; cin \u0026gt;\u0026gt; type; if(type==1) { //range sum  int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; \u0026#34;Ans:\u0026#34; \u0026lt;\u0026lt; tree.range_sum(l, r) \u0026lt;\u0026lt; endl; } else{ //add to all elements  int l, r, v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; tree.update_range(l, r, v); } } return 0; } Segment Trees template\u0026lt;typename T\u0026gt; class SegmentTree { int n; vector\u0026lt;T\u0026gt; seg; public: SegmentTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr):seg(2*n+1,0) { this-\u0026gt;n=n; for(int i=0;i\u0026lt;n;++i) seg[i+n]=arr[i]; for(int i=n-1;i\u0026gt;0;--i) seg[i]=seg[2*i]+seg[2*i+1]; } void update(int i,T v) { i+=n; seg[i]+=v; while(i\u0026gt;1) { i/=2; seg[i]=seg[2*i]+seg[2*i+1]; } } T query(int l,int r) { //l inclusive r excluded  l+=n; r+=n; T sum=0; while(l\u0026lt;r) { if(l\u0026amp;1) sum+=seg[l],l++; if(r\u0026amp;1) r--,sum+=seg[r]; l/=2; r/=2; } return sum; } }; LCA class LCA { int n, q, D; vector\u0026lt;int\u0026gt; lev; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adj; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; public: LCA(int n,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; adj) { this-\u0026gt;n = n; this-\u0026gt;adj = adj; lev.assign(n + 1, 0); D = 31; dp.assign(n + 1, vector\u0026lt;int\u0026gt;(D + 1, 0)); } int walk(int i, int k) { for (int d = 0; d \u0026lt;= D; ++d) if (k \u0026amp; (1 \u0026lt;\u0026lt; d)) i = dp[i][d]; return i; } void dfs(int i, int l, int p) { if (p != -1) dp[i][0] = p; lev[i] = l; for (auto it : adj[i]) if (it != p) dfs(it, l + 1, i); } void preprocess() { for (int d = 1; d \u0026lt;= D; ++d) { for (int i = 1; i \u0026lt;= n; ++i) { int mid = dp[i][d - 1]; if (mid != 0) { dp[i][d] = dp[mid][d - 1]; } } } } int lca(int x, int y) { if (lev[x] \u0026gt; lev[y]) x = walk(x, lev[x] - lev[y]); else if (lev[x] \u0026lt; lev[y]) y = walk(y, lev[y] - lev[x]); if (x == y) return x; for (int d = D; d \u0026gt;= 0; --d) { if (dp[x][d] != dp[y][d]) { x = dp[x][d]; y = dp[y][d]; } } return dp[x][0]; } int dist(int x,int y) { //handle root cases differently  return lev[x] + lev[y] - 2 * lev[lca(x, y)]; } }; ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/template-library/","summary":"Fenwick Tree #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; class FenwickTree { vector\u0026lt;T\u0026gt; BIT; int n; public: FenwickTree(int n,vector\u0026lt;T\u0026gt;\u0026amp; arr,T def) { BIT.assign(n + 1, def); this-\u0026gt;n = n; } void update(int i,T v) { while (i \u0026lt;= n) BIT[i] += v, i += i \u0026amp; -i; } T query(int i,T def) { //get from 0 to i  T sum = def; while(i\u0026gt;0) sum += BIT[i], i -= i \u0026amp; -i; return sum; } }; class RangeFenwickTree { int n; vector\u0026lt;int\u0026gt; BIT1; vector\u0026lt;int\u0026gt; BIT2; public: RangeFenwickTree(int n,vector\u0026lt;int\u0026gt;\u0026amp; arr) { this-\u0026gt;n = n; BIT1.","tags":null,"title":"Template Library"},{"categories":null,"contents":"General TC \nHarmonic Sum Analysis When a function goes in the form of for(int i=1;i\u0026lt;=n;++i) { for(int j=2*i;j\u0026lt;=n;j+=i) cout\u0026lt;\u0026lt;(i,j); } \nThe Summation part takes O(logN) hence the total time is O(N*logN)\nNote: Find Why it is logN ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/time-complexity/","summary":"General TC \nHarmonic Sum Analysis When a function goes in the form of for(int i=1;i\u0026lt;=n;++i) { for(int j=2*i;j\u0026lt;=n;j+=i) cout\u0026lt;\u0026lt;(i,j); } \nThe Summation part takes O(logN) hence the total time is O(N*logN)\nNote: Find Why it is logN ","tags":null,"title":"Time Complexity Analysis"},{"categories":null,"contents":"Some Facts about trees  Simple path is a path that doesn\u0026rsquo;t contain any node twice. A tree has n-1 edges!  Segment Trees Use segment trees for questions on updating values and querying. Can be used with complex operations like pairs,sets etc. Find very effecient and faster updating (used to insert too), by Finding path to root from one node.\nvoid update(int pos,int val){ pos += k; tree[pos] = val; int odd = 1; //this switches between alternate levels of the segment tree goes upwards  while(pos\u0026gt;\u0026gt;=1 \u0026gt;0){ /* use this in case for level switching if(odd) tree[pos] = tree[2*pos] | tree[2*pos+1]; else tree[pos] = tree[2*pos] ^ tree[2*pos+1]; odd = 1-odd; */ tree[pos]=tree[2*pos]+tree[2*pos+1]; } } for(int i=0;i\u0026lt;n;i++){ int val; cin\u0026gt;\u0026gt;val; update(i,val); } ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/trees/","summary":"Some Facts about trees  Simple path is a path that doesn\u0026rsquo;t contain any node twice. A tree has n-1 edges!  Segment Trees Use segment trees for questions on updating values and querying. Can be used with complex operations like pairs,sets etc. Find very effecient and faster updating (used to insert too), by Finding path to root from one node.\nvoid update(int pos,int val){ pos += k; tree[pos] = val; int odd = 1; //this switches between alternate levels of the segment tree goes upwards  while(pos\u0026gt;\u0026gt;=1 \u0026gt;0){ /* use this in case for level switching if(odd) tree[pos] = tree[2*pos] | tree[2*pos+1]; else tree[pos] = tree[2*pos] ^ tree[2*pos+1]; odd = 1-odd; */ tree[pos]=tree[2*pos]+tree[2*pos+1]; } } for(int i=0;i\u0026lt;n;i++){ int val; cin\u0026gt;\u0026gt;val; update(i,val); } ","tags":null,"title":"Trees"},{"categories":null,"contents":" Binary Search :\nTutorial, Problems, Tutorial, Implementation, Problem Quicksort :\nTutorial, Implementation,  Tutorial Merge Sort :\nTutorial, Implementation,  Tutorial Suffix Array :\nTutorial, Tutorial, Implementation, Tutorial, Implementation, Problem, Problem Knuth-Morris-Pratt Algorithm (KMP) :\nTutorial, Tutorial, Implementation, Tutorial, Problem Rabin-Karp Algorithm :\nTutorial, Implementation,  Tutorial, Problem, Problem Tries :\nTutorial, Problems, Tutorial : I, II, Tutorial, Problem, Problem, Problem Depth First Traversal of a Graph :\nTutorial, Implementation,  Tutorial, Problems, Problem, Problem, Problem Breadth First Traversal of a Graph :\nTutorial, Implementation,  Tutorial, Problems, Problem, Problem, Problem, Flood Fill Dijkstraâ€™s Algorithm :\nTutorial, Problems, Problem, Tutorial(greedy), Tutorial (with heap), Implementation, Problem, Problem Binary Indexed Tree :\nTutorial, Problems, Tutorial, Original Paper, Tutorial, Tutorial, Problem, Problem,\nProblem, Problem, Problem, Problem, Problem Segment Tree (with lazy propagation) :\nTutorial, Implementation, Tutorial, Tutorial, Problems, Implementation, Tutorial, Implementation and Various Uses, Persistent Segment Tree: *62, II, problems same as BIT, Problem, Problem/HLD is used as well/ Z algorithm :\nTutorial, Problem, Tutorial, Tutorial, problems same as KMP. Floyd Warshall Algorithm :\nTutorial, Implementation, Problem, Problem Sparse Table (LCP, RMQ) :\nTutorial, Problems, Tutorial, Implementation(C++), Java implementation Heap / Priority Queue / Heapsort :\nImplementation, Explanation, Tutorial, Implementation, Problem, Chapter from CLRS Modular Multiplicative Inverse Binomial coefficients (nCr % M): Tutorial, Tutorial, Paper (Link Not Working), Problem Suffix Automaton :\nDetailed Paper, Tutorial, Implementation (I), Tutorial, Implementation (II), Problem, Problem, Problem, Problem, Tutorial, Implementation Lowest Common Ancestor :\nTutorial, Problems, Paper, Paper, Problem, Problem, Problem Counting Inversions :\nDivide and Conquer, Segment Tree, Fenwick Tree, Problem Euclidâ€™s Extended Algorithm Suffix Tree :\nTutorial, Tutorial, Intro, Construction : *106, II, Implementation, Implementation, Problem, Problem, Problem, Problem Dynamic Programming :\nChapter from CLRS(essential),  Tutorial, Problems, Problem, Problem, Problem, Problem, Tutorial, Problem, Problem, Problem, Longest Increasing Subsequence, Bitmask DP, Bitmask DP, Optimization, Problem, Problem, Problem, Problem, Problem, Problem, Problem, DP on Trees : *134, II Basic Data Structures :\nTutorial, Stack Implementation, Queue Implementation, Tutorial, Linked List Implementation Logarithmic Exponentiation Graphs :\nDefinition, Representation,  Definition, Representation, Problem, Problem Minimum Spanning Tree :\nTutorial, Tutorial, Kruskalâ€™s Implementation, Primâ€™s Implementation, Problem, Problem, Problem, Problem, Problem Efficient Prime Factorization Combinatorics :\nTutorial, Problems, Problem, Tutorial Union Find/Disjoint Set :\nTutorial, Tutorial, Problems, Problem, Problem, Problem Knapsack problem :\nSolution, Implementation Aho-Corasick String Matching Algorithm :\nTutorial, Implementation, Problem, Problem, Problem, Problem Strongly Connected Components :\nTutorial, Implementation, Tutorial, Problem, Problem, Problem Bellman Ford algorithm :\nTutorial, Implementation, Tutorial, Implementation, Problem, Problem Heavy-light Decomposition :\nTutorial, Problems, Tutorial, Implementation, Tutorial, Implementation, Implementation, Problem, Problem, Problem Convex Hull :\nTutorial, Jarvis Algorithm Implementation, Tutorial with Graham scan, Tutorial, Implementation, Problem, Problem, Problem, Problem, Problem Line Intersection :\nTutorial, Implementation,  Tutorial, Problems Sieve of Erastothenes Interval Tree :\nTutorial, Implementation, Problem, Problem, Problem, Problem, Problem, Problem, Tutorial Counting Sort Probabilities Matrix Exponentiation :\nTutorial, Tutorial Network flow :\n(Max Flow)Tutorial : I, II, Max Flow(Ford-Fulkerson) Tutorial, Implementation, (Min Cut) Tutorial, Implementation, (Min Cost Flow)Tutorial : I, II, III, Dinicâ€™s Algorithm with Implementation, Max flow by Edmonds Karp with Implementation, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem K-d tree :\nTutorial, Tutorial, Implementation, Problem Deque Binary Search Tree :\nTutorial, Implementation, Searching and Insertion, Deletion Quick Select :\nImplementation, Implementation Treap/Cartesian Tree :\nTutorial(detailed), Tutorial, Implementation, Uses and Problems, Problem, Problem Game Theory :\nDetailed Paper, Tutorial, Problems, Grundy Numbers, Tutorial with example problems - I, II,III, IV, Tutorial, Problems, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Problem, Nim STL (C++) :\nI, II, Crash Course Maximum Bipartite Matching Manacherâ€™s Algorithm :\nImplementation, Tutorial, Tutorial, Implementation, Tutorial, Implementation, Problem, Problem, Problem Miller-Rabin Primality Test : Code Stable Marriage Problem Hungarian Algorithm, Tutorial Sweep line Algorithm : I, II LCP :\nTutorial, Implementation, Tutorial, Implementation Gaussian Elimination Pollard Rho Integer Factorization, problem Topological Sorting Detecting Cycles in a Graph : Directed - *293, IIUndirected : *295 Geometry : Basics, Tutorial Backtracking :\nN queens problem, Tug of War, Sudoku Eulerian and Hamiltonian Paths :\nTutorial, Tutorial, (Eulerian Path and Cycle)Implementation, (Hamiltonian Cycle)Implementation Graph Coloring :\nTutorial, Implementation Meet in the Middle :\nTutorial, Implementation Arbitrary Precision Integer(BigInt), II Radix Sort, Bucket Sort Johnsonâ€™s Algorithm :\nTutorial, Tutorial, Implementation Maximal Matching in a General Graph :\nBlossom/Edmondâ€™s Algorithm, Implementation, Tutte Matrix, Problem Recursion : I, II, Towers of Hanoi with explanation Inclusion and Exclusion Principle : I, II Co-ordinate Compression Sqrt-Decomposition :\nTutorial, Tutorial, Problem, Problem Link-Cut Tree :\nTutorial, Wiki, Tutorial, Implementation, Problem, Problem, Problem, Problem Eulerâ€™s Totient Function :\nExplanation, Implementation, Problems, Explanation, Problems Burnside Lemma :\nTutorial, Tutorial, Problem Edit/Levenshtein Distance :\nTutorial, Introduction, Tutorial, Problem, Problem Branch and Bound Math for Competitive Programming Moâ€™s Algorithm : Tutorial and Problems  ","date":"June 8, 2020","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/posts/tutorial-links/","summary":"Binary Search :\nTutorial, Problems, Tutorial, Implementation, Problem Quicksort :\nTutorial, Implementation,  Tutorial Merge Sort :\nTutorial, Implementation,  Tutorial Suffix Array :\nTutorial, Tutorial, Implementation, Tutorial, Implementation, Problem, Problem Knuth-Morris-Pratt Algorithm (KMP) :\nTutorial, Tutorial, Implementation, Tutorial, Problem Rabin-Karp Algorithm :\nTutorial, Implementation,  Tutorial, Problem, Problem Tries :\nTutorial, Problems, Tutorial : I, II, Tutorial, Problem, Problem, Problem Depth First Traversal of a Graph :\nTutorial, Implementation,  Tutorial, Problems, Problem, Problem, Problem Breadth First Traversal of a Graph :","tags":null,"title":"Tutorial Links"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://rajagopalan-gangadharan.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]