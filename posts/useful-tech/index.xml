<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Useful Techniques on Rajagopalan's Space</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/</link><description>Recent content in Useful Techniques on Rajagopalan's Space</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Jun 2020 08:06:25 +0600</lastBuildDate><atom:link href="https://rajagopalan-gangadharan.github.io/posts/useful-tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Bellman Ford</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/bellman-ford/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/bellman-ford/</guid><description/></item><item><title>Binary Search</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/binary-search/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/binary-search/</guid><description>Increasing Array lower_bound() returns value that is greater than or equal to x;
upper_bound() returns value strictly greater than x;
Decreasing array: lower_bound() returns value that is less than or equal to x;
upper_bound() retruns value that is strictly less than x;</description></item><item><title>DFS Order</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/dfs-order/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/dfs-order/</guid><description>A very useful technique.It basically has 2 arrays one is Intime and the other is outTime. inTime says when it enters a recursion stack and outTime says when it exits the recursion stack. It is useful to check if a node v is present in the subtree of node u. If inTime[u]&amp;lt;inTime[v] and outTime[u]&amp;gt; outTime[v].
It can also be useful in counting number of nodes that belong to a particular tree at a particular height.</description></item><item><title>LCA</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/</guid><description>LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -&amp;gt; N is number of nodes 2^k&amp;lt;=N So k&amp;lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -&amp;gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table.</description></item><item><title>Patience Sort</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/patience-sort/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/patience-sort/</guid><description>It is an online sorting algorithm aimed to create piles of cards in such a way that piles are in increasing order down wards.
It can be used to find LIS in O(NlogN) time. Can also be used to find (minimum)number of distinct LIS.
VII dp; for(int i=arr.size()-1;i&amp;gt;=0;--i) { int x=arr[i]; auto it=upper_bound(all(dp),x); if(it==dp.end()) dp.pb(x); else *it=x; } cout&amp;lt;&amp;lt;dp.size();</description></item><item><title>SCC</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/scc/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/scc/</guid><description>Kosaraju&amp;rsquo;s SCC A strongly Connected Component is for a directed graph. For an undirected graph we say it is a connected Component if we can reach a vertex from any vertex of a connected component. In case of SCC its same but called differently.
Steps Perform DFS in forward graph and make a note of nodes in decreasing order of outtime. Perform DFS in reverse graph(instead of for loop use the decreasing order u found).</description></item></channel></rss>