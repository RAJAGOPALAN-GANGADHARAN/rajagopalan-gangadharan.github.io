<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Useful Techniques on Rajagopalan's Space</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/</link><description>Recent content in Useful Techniques on Rajagopalan's Space</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Jun 2020 08:06:25 +0600</lastBuildDate><atom:link href="https://rajagopalan-gangadharan.github.io/posts/useful-tech/index.xml" rel="self" type="application/rss+xml"/><item><title>LCA</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-tech/lca/</guid><description>LCA Using Binary Lifting k=0 means the parent node Create a table P[K][N] -&amp;gt; N is number of nodes 2^k&amp;lt;=N So k&amp;lt;=logN Hence Size of table is N*logN jumps are made in order of powers of 2 -&amp;gt;1,2,4...etc trying to divide by 2 let mid=par[i][k-1] (2^(k-1)th parent if exists) par[i][k] is par[mid][k-1] Its basically dividing a big jump into 2. First make 2 nodes that we are going to find LCA to same depth using Walk function if current jump results -1 then we have jumped of the table.</description></item></channel></rss>