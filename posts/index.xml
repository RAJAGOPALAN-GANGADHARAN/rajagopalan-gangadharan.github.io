<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Rajagopalan</title><link>https://rajagopalan-gangadharan.github.io/posts/</link><description>Recent content in Posts on Rajagopalan</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Jun 2020 08:06:25 +0600</lastBuildDate><atom:link href="https://rajagopalan-gangadharan.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Search Results</title><link>https://rajagopalan-gangadharan.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>General facts</title><link>https://rajagopalan-gangadharan.github.io/posts/general/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/general/</guid><description>Online vs Offline Online algorithm means getting output after processing at ith element for eg: median of a stream of elements, Whereas in case of online means using all n elements to arrive at an output.</description></item><item><title>Math facts</title><link>https://rajagopalan-gangadharan.github.io/posts/maths/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/maths/</guid><description>Segmented Sieve Use When we have to generate large number of prime Numbers Click Here
BitHacks Number of bits required to represent a number:
For More Bit Tricks:Click Here Useful nCr Technique Divide by their GCD&amp;rsquo;s to prevent overflow
For fast Calculation:
ll NcR(ll n, ll r) { ll p = 1, k = 1; if (n - r &amp;lt; r) r = n - r; if (r !</description></item><item><title>Template Library</title><link>https://rajagopalan-gangadharan.github.io/posts/template-library/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/template-library/</guid><description>Fenwick Tree #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; template&amp;lt;typename T&amp;gt; class FenwickTree { vector&amp;lt;T&amp;gt; BIT; int n; public: FenwickTree(int n,vector&amp;lt;T&amp;gt;&amp;amp; arr,T def) { BIT.assign(n + 1, def); this-&amp;gt;n = n; } void update(int i,T v) { while (i &amp;lt;= n) BIT[i] += v, i += i &amp;amp; -i; } T query(int i,T def) { //get from 0 to i T sum = def; while(i&amp;gt;0) sum += BIT[i], i -= i &amp;amp; -i; return sum; } }; class RangeFenwickTree { int n; vector&amp;lt;int&amp;gt; BIT1; vector&amp;lt;int&amp;gt; BIT2; public: RangeFenwickTree(int n,vector&amp;lt;int&amp;gt;&amp;amp; arr) { this-&amp;gt;n = n; BIT1.</description></item><item><title>Time Complexity Analysis</title><link>https://rajagopalan-gangadharan.github.io/posts/time-complexity/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/time-complexity/</guid><description>General TC
Harmonic Sum Analysis When a function goes in the form of for(int i=1;i&amp;lt;=n;++i) { for(int j=2*i;j&amp;lt;=n;j+=i) cout&amp;lt;&amp;lt;(i,j); }
The Summation part takes O(logN) hence the total time is O(N*logN)
Note: Find Why it is logN</description></item><item><title>Tutorial Links</title><link>https://rajagopalan-gangadharan.github.io/posts/tutorial-links/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/tutorial-links/</guid><description>Binary Search :
Tutorial, Problems, Tutorial, Implementation, Problem Quicksort :
Tutorial, Implementation, Tutorial Merge Sort :
Tutorial, Implementation, Tutorial Suffix Array :
Tutorial, Tutorial, Implementation, Tutorial, Implementation, Problem, Problem Knuth-Morris-Pratt Algorithm (KMP) :
Tutorial, Tutorial, Implementation, Tutorial, Problem Rabin-Karp Algorithm :
Tutorial, Implementation, Tutorial, Problem, Problem Tries :
Tutorial, Problems, Tutorial : I, II, Tutorial, Problem, Problem, Problem Depth First Traversal of a Graph :
Tutorial, Implementation, Tutorial, Problems, Problem, Problem, Problem Breadth First Traversal of a Graph :</description></item></channel></rss>