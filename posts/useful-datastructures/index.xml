<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Trees on Rajagopalan</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/</link><description>Recent content in Trees on Rajagopalan</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Jun 2020 08:06:25 +0600</lastBuildDate><atom:link href="https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/index.xml" rel="self" type="application/rss+xml"/><item><title>Trees</title><link>https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/trees/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://rajagopalan-gangadharan.github.io/posts/useful-datastructures/trees/</guid><description>Some Facts about trees Simple path is a path that doesn&amp;rsquo;t contain any node twice. A tree has n-1 edges! Segment Trees Use segment trees for questions on updating values and querying. Can be used with complex operations like pairs,sets etc. Find very effecient and faster updating (used to insert too), by Finding path to root from one node.
void update(int pos,int val){ pos += k; tree[pos] = val; int odd = 1; //this switches between alternate levels of the segment tree goes upwards while(pos&amp;gt;&amp;gt;=1 &amp;gt;0){ /* use this in case for level switching if(odd) tree[pos] = tree[2*pos] | tree[2*pos+1]; else tree[pos] = tree[2*pos] ^ tree[2*pos+1]; odd = 1-odd; */ tree[pos]=tree[2*pos]+tree[2*pos+1]; } } for(int i=0;i&amp;lt;n;i++){ int val; cin&amp;gt;&amp;gt;val; update(i,val); }</description></item></channel></rss>